import Mathlib.Topology.Constructions
import Mathlib.Topology.Order
import Mathlib
set_option autoImplicit true


noncomputable section

open Function Set Filter Topology TopologicalSpace

universe u v w
/-!
# Irrational Slope Topology
Here we construct a structure `UpperHalfRationals` and then construct a Topological Space on it, called the Irrational Slope Topology. `UpperHalfRationals` is the set of all the rational points in the upper Half Euclidean Plane.
From [N. Bourbaki, *General Topology*][bourbaki1966] we know that a unique Topological Space can be constructed from neighbourhood filters of a point. We construct the neighbourhood filter of a point in `UpperHalfRationals` and then construct the Irrational Slope Topology on it. 

-/
/-!
# Neighbourhood : 
For any topological space `τ` and `x`, the sets of `τ` which contains an open set containing `x` is a neighbourhood  
Let `γ :`Sets of all neighbourhoods of `x`, then it has the following properties :-
* Every Set `X` which contains the set belonging to `γ`, itself belongs to `γ`.
* Every finite intersection of sets of `γ` belongs to `γ`
* The element `x` is in every set of `γ`

-/


/--Upper Half Rationals Space where we include all the rational points in the upper Half Euclidean Plane-/
@[ext]
structure UpperHalfRationals where
  x : ℚ
  y : ℚ
  hy : 0 ≤  y


notation "ℚ+" => UpperHalfRationals

/--Open Ball of ℚ+ given `ε : ℝ(radii)` and `ζ : ℝ (centre)`  -/
@[inline]
def B (ε : ℝ)(ζ : ℝ) : Set ℚ+ := {z : ℚ+ | ‖z.x - ζ‖ < ε ∧ z.y = 0}
/-! Remark : This open ball is not an open set in the Topology generated -/

/--Constructing the fundamental system of neighbourhoods of a point-.
# The fundamental system of neighbourhoods(ζ) :
For any point `x : ℚ+`, such that for each neighbourhood `V` of `x`, there is a neighbourhood `W ∈ ζ` such that `W ⊂ V`.
-/
@[inline]
def nhs_dit (θ : ℝ)(ε : ℝ)(z : ℚ+) : Set ℚ+ := {z} ∪ B ε (z.x - z.y / θ) ∪ B ε (z.x + z.y / θ)

/-! 
The main idea about neighbourhoods of a point in IST is the fact that neighbourhoods are constructed of 2 open balls whose centre is an irrational points (z.x ± z.y/θ ), the line joining these points to (x,y) have slope ±θ. 
-/
/--Smaller Ball is contained in a Bigger Ball-/
lemma B_le (ε₁ : ℝ)(ε₂ : ℝ )(z : ℝ)(hε : ε₁ ≥  ε₂) : B ε₂ z ⊆ B ε₁ z :=
  by
    rw[B,B]
    simp only [Real.norm_eq_abs, setOf_subset_setOf, and_imp]
    intro x hx h
    apply And.intro
    · apply lt_of_lt_of_le hx
      assumption
    · assumption

/--Smaller neighbourhood is contained in the Larger Neighbourhood-/
lemma nhs_le (θ : ℝ)(ε₁ : ℝ)(ε₂ : ℝ )(z : ℚ+)(hε : ε₁ ≥  ε₂) : nhs_dit θ ε₂ z ⊆ nhs_dit θ ε₁ z := by
  rw[nhs_dit,nhs_dit]
  intro x hx
  simp only [singleton_union, mem_union, mem_insert_iff]
  simp only [singleton_union, mem_union, mem_insert_iff] at hx
  cases hx with
    | inl hl =>
      cases hl with
        | inl hll =>
          left
          left
          assumption
        | inr hlr =>
          left
          right
          apply B_le<;>
          assumption
    | inr hr  =>
      right
      apply B_le<;>
      assumption

/-! Filter: A Filter`F` is a set of sets which satisfies :-
* `B ∈ F`and `A ⊆ B`, then `A ∈ F`.
* If `A ∈ F` and `B ∈ F`, then `A ∩ B ∈ F`.
 So, in the following lemma ,we prove the fact that sets that contain the neighbourhoods generate a filter around a point. 
 -/
 /-! Since every neighbourhood containns a set which is an elemnent of fundamental system of neighbourhoods of a point `x`, so the neighbourhood filter of a point `x` will be the set of sets that will contain the elements of fundamental system of a point `x`.
  -/

/-! Neighbourhood filter of a point `x`-/
def nhs_filter_sets(θ : ℝ)(z : ℚ+) : Set (Set ℚ+):= {t | ∃ ε : ℝ , t ⊇ nhs_dit θ ε z ∧ ε > 0}


/--Proof that the Neighbourhood filter of a point is a filter-/
def filter_gen (θ : ℝ)(z : ℚ+) : Filter ℚ+
    where
  sets := { t | ∃ ε : ℝ , t ⊇  nhs_dit θ ε z ∧ ε > 0}
  univ_sets := by
    simp only [gt_iff_lt, mem_setOf_eq, subset_univ, true_and]
    use 1
    simp only [zero_lt_one]
  sets_of_superset := by
    rintro x y hx hxy
    simp only [mem_setOf_eq] at hx
    simp only [mem_setOf_eq]
    match hx with
      | ⟨ε,hx,hε⟩ =>
        use ε
        constructor
        trans
        exact hxy
        exact hx
        assumption
  inter_sets := by
    rintro x y ⟨ε₁,hx⟩ ⟨ε₂,hy⟩
    use min ε₁ ε₂
    constructor
    apply subset_inter
    · trans
      apply nhs_le θ ε₁ (min ε₁ ε₂)
      simp only [ge_iff_le, min_le_iff, le_refl, true_or]
      exact hx.1
    · trans
      apply nhs_le θ ε₂ (min ε₁ ε₂)
      simp only [ge_iff_le, min_le_iff, le_refl, or_true]
      exact hy.1
    apply lt_min hx.2 hy.2



/--The Irrational Slope Topology Generated by the above mentioned filter-/
def IrrationalSlopeTopology_mk (θ : ℝ)(hθ : Irrational θ) : TopologicalSpace ℚ+ :=
  TopologicalSpace.mkOfNhds (filter_gen θ)

/--Neighbourhood of a point on the x-axis is just the open ball for the point-/
lemma xaxisnhs  (θ : ℝ)(ε : ℝ)(z : ℚ+)(hy : z.y = 0)(hε : ε > 0) : nhs_dit θ ε z = B ε z.x := by
  rw[nhs_dit]
  simp only [hy, Rat.cast_zero, zero_div, sub_zero, add_zero]
  have hz : z ∈ B ε z.x := by
    rw[B]
    simp
    constructor<;>
    assumption
  simp only [singleton_union, hz, insert_eq_of_mem, union_self]

/--Auxiliary Statement proving the following lemma-/
lemma purenhsdit (θ : ℝ): pure ≤ filter_gen θ := by
  intros z n hnz
  simp only [mem_pure]
  rw[filter_gen] at hnz
  simp at hnz
  match hnz with
    | ⟨ε,hnε,_⟩ =>
      apply Set.mem_of_subset_of_mem hnε
      rw[nhs_dit]
      simp only [singleton_union, mem_union, mem_insert_iff, true_or]

/--There exists an open ball containing any neighbourhood of a point on the x-axis-/
lemma nhs_dit_subs (θ : ℝ)(ε : ℝ)(p : ℝ)(a : ℚ+)(hay : a.y = 0)(hinq : |a.x - p| < ε )(hε : ε > 0 ) : ∃ ε₂ : ℝ , nhs_dit θ ε₂ a ⊆ B ε p ∧ ε₂ > 0  := by
  by_cases hap : a.x - p = 0
  · use ε
    rw[xaxisnhs θ ε a hay]
    have hpa : p = a.x := by
      linarith
    rw[←hpa]
    constructor
    triv
    repeat assumption
  · set r : ℝ := |a.x - p| with hr
    set ε₂ := (ε - r)/2  with hε₂
    use ε₂
    constructor
    rw[xaxisnhs θ ε₂ a hay]
    rw[B,B]
    simp only [Real.norm_eq_abs, setOf_subset_setOf, and_imp]
    intro z hz h
    rw[← hr] at hz
    constructor
    have hzp : |z.x - p| ≤ |z.x - a.x| + |a.x - p| := by
      norm_num
      have hzpeq : z.x - p = (z.x - a.x) + (a.x - p) := by
        linarith
      rw[hzpeq]
      apply abs_add
    have hεr : ε > (ε + r)/2 := by
      linarith
    have hεrmod : |↑z.x - a.x| + |a.x - p| < (ε - r)/2 + r := by
      norm_num
      rw[← hr]
      exact hz
    linarith
    assumption
    repeat linarith

/--Proving the fact that the Neighbourhood filter generated as filter_gen is the topological neighbourhood filter for the Irrational Slope Topology above. -/
theorem nhds_dit_filter_gen (θ : ℝ)(hθ : Irrational θ)(z : ℚ+) : @nhds ℚ+ (IrrationalSlopeTopology_mk θ hθ) z = filter_gen θ z:= by
  apply nhds_mkOfNhds
  exact purenhsdit θ
  intros a s hs
  rw[filter_gen] at hs
  simp at hs
  match hs with
    | ⟨ε,hsε,hε⟩ =>
      set t := nhs_dit θ ε a with ht
      use t
      constructor
      rw[filter_gen]
      simp only [gt_iff_lt, Filter.mem_mk, mem_setOf_eq]
      use ε
      constructor
      assumption
      intros a' hat
      rw[filter_gen]
      simp only [gt_iff_lt, Filter.mem_mk, mem_setOf_eq]
      rw[ht,nhs_dit] at hat
      simp at hat
      cases hat with
      | inl hl =>
        cases hl with
        | inl hll =>
          rw[hll]
          use ε
        | inr hlr =>
          rw[B] at hlr
          simp only [Real.norm_eq_abs, mem_setOf_eq] at hlr
          have lem : ∃ ε₂ : ℝ , nhs_dit θ ε₂ a' ⊆ B ε (↑a.x - ↑a.y / θ) ∧ ε₂ > 0 := nhs_dit_subs θ ε (a.x - a.y / θ) a' hlr.2 hlr.1 hε
          match lem with
          | ⟨ε₂,hε₂⟩ =>
            use ε₂
            constructor
            trans
            exact hsε
            rw[ht,nhs_dit]
            trans
            any_goals exact hε₂.1
            intro x hx
            simp only [singleton_union, mem_union, mem_insert_iff]
            left
            right
            assumption
            exact hε₂.2
      | inr hr =>
        rw[B] at hr
        simp only [Real.norm_eq_abs, mem_setOf_eq] at hr
        have lem : ∃ ε₂ : ℝ , nhs_dit θ ε₂ a' ⊆ B ε (↑a.x + ↑a.y / θ) ∧ ε₂ > 0 := nhs_dit_subs θ ε (a.x + a.y / θ) a' hr.2 hr.1 hε
        match lem with
          | ⟨ε₂,hε₂⟩ =>
            use ε₂
            constructor
            trans
            exact hsε
            rw[ht,nhs_dit]
            trans
            any_goals exact hε₂.1
            simp only [singleton_union, subset_union_right]
            exact hε₂.2

section IrrationalSlopeTopology
/-!
# Plan to formalize that this space is T2.
* From [N. Bourbaki, *General Topology*][bourbaki1966], if we take the Space to be T2 Space. we need to prove the fact that distinct points admit distinct neighbourhoods and we are done. There exists an open set in those neighbourhoods , thus we get distinct open sets too.
* So we need the following facts :
  * Distinct points will have neighbourhoods of open balls that are centred at distinct points
  * For any 2 distinct points on the line, we can construct disjoint open balls
  * So, the fundamental neighbourhoods that are constructed from these disjoint balls are disjoint. Hence, we are done.  

-/


variable (θ : ℝ)(hθ : Irrational θ)[t : TopologicalSpace ℚ+](topology_eq : t = IrrationalSlopeTopology_mk θ hθ)

/--Theorem showing what conditions should a set satisfy to be deemed as a neighbourhood of a point-/
theorem IST_nhs_iff (z : ℚ+)(s : Set ℚ+) : s ∈ @nhds ℚ+ t z ↔ ∃ ε : ℝ , s ⊇ nhs_dit θ ε z ∧ ε > 0 := by
  rw[topology_eq]
  rw[ nhds_dit_filter_gen θ hθ z]
  rw[filter_gen]
  simp only [gt_iff_lt, Filter.mem_mk, mem_setOf_eq]

/--For any 2 distinct real numbers, one can generate 2  disjoint open balls -/
lemma B_disjoint_ball_construct (z₁ : ℝ)(z₂ : ℝ)(hz1z2 : z₁ ≠ z₂) : ∃ ε₁ ε₂ : ℝ , (B (ε₁) z₁ ∩ B (ε₂) z₂ = ∅) ∧ (ε₁ > 0) ∧ (ε₂ > 0) := by
  set ε₁ := |z₁ - z₂|/3 with hε₁
  use ε₁, ε₁
  have hz : |z₁ - z₂| > 0 := by
    simp[hz1z2]
    by_contra lem
    apply hz1z2
    linarith
  constructor
  rw[B,B]
  simp only [Real.norm_eq_abs]
  by_contra h
  push_neg at h
  rw[ nonempty_def] at h
  match h with
  |⟨x,hx⟩  =>
    simp at hx
    match hx with
    | ⟨⟨hax,_⟩,⟨hbx,_⟩⟩ =>
    have hxz : |z₁ - z₂| ≤ |z₁ - x.x| + |x.x - z₂| := by
      norm_num
      have hzpeq : z₁ - z₂ = (z₁ - x.x) + (x.x - z₂) := by
        linarith
      rw[hzpeq]
      apply abs_add
    have hmodxz : |x.x - z₁| = |z₁ - x.x| := by
      apply abs_sub_comm
    have hε₁ε₂ : |z₁ - x.x| + |x.x - z₂| < ε₁ + ε₁ := by
      rw[←hmodxz,hε₁]
      linarith
    have hab : |z₁ - z₂| < ε₁ + ε₁ := by
      linarith
    rw[hε₁] at hab
    linarith
  constructor<;>
  linarith

/--If z1 and z2 are distict points, then z1.x - z1.y/θ ≠ z2.x - z2.y/θ(The arguement rests on the fact that θ is irrational) -/
lemma distinct_points_z1_z2 (z1 : ℚ+)(z2 : ℚ+)(hlemma : z1 ≠ z2):  z1.x - z1.y/θ ≠ z2.x - z2.y/θ := by
  by_contra h
  have hz : z1.x - z2.x = (z1.y - z2.y)/θ :=
    calc
      z1.x - z2.x = z1.x - z1.y/θ + z1.y/θ - z2.x := by
        simp only [sub_add_cancel]
      _ = z2.x - z2.y/θ + z1.y/θ - z2.x := by
        rw[h]
      _ = (z1.y - z2.y)/θ := by
        ring
  by_cases hzy_eq : z1.y = z2.y
  · have hzx : z1.x = z2.x := by
      rw[hzy_eq] at hz
      simp only [sub_self, zero_div] at hz
      norm_cast at hz
      linarith
    have hzeq : z1 = z2 := by
      apply UpperHalfRationals.ext
      simp only [hzx,hzy_eq]
      exact hzy_eq
    exact hlemma hzeq
  · apply Irrational.ne_rat
    apply Irrational.rat_div
    exact hθ
    have hzy : z1.y - z2.y ≠ 0 := by
      intro hzya
      apply hzy_eq
      linarith
    exact hzy
    norm_cast at hz
    exact hz.symm

/--If z1 and z2 are distict then z1.x - z1.y/θ ≠ z1.x + z2.y/θ  -/
lemma distinct_points_z1_z2_diff (z1 : ℚ+)(z2 : ℚ+)(hlemma : z1 ≠ z2):  z1.x - z1.y/θ ≠ z2.x + z2.y/θ := by
  by_contra h
  have hz : z1.x - z2.x = (z1.y + z2.y)/θ :=
    calc
      z1.x - z2.x = z1.x - z1.y/θ + z1.y/θ - z2.x := by
        simp only [sub_add_cancel]
      _ = z2.x + z2.y/θ + z1.y/θ - z2.x := by
        rw[h]
      _ = (z1.y + z2.y)/θ := by
        ring
  norm_cast at hz
  have hy1 : z1.y ≥  0 := z1.hy
  have hy2 :z2.y ≥ 0 := z2.hy
  by_cases hzy_eq : z1.y = -z2.y
  · have hy10 : z1.y = 0 := by
      linarith
    have hy20 : z2.y = 0 := by
      linarith
    have hzeq : z1 = z2 := by
      rw[hy10,hy20] at hz
      simp at hz
      norm_cast at hz
      apply UpperHalfRationals.ext
      repeat linarith
    exact hlemma hzeq
  · apply Irrational.ne_rat
    apply Irrational.rat_div
    exact hθ
    have hzy : z1.y + z2.y ≠ 0 := by
      intro hzya
      apply hzy_eq
      linarith
    exact hzy
    exact hz.symm

/--Auxiliary Lemma about disjointness-/
lemma distinct_sets{A : Set ℚ+}{B : Set ℚ+}{C : Set ℚ+}{D : Set ℚ+}(hA : A ∩ D = ∅)(hB : B ∩ D = ∅)(hC : C ∩ D = ∅):  (A ∪ B ∪ C) ∩ D = ∅ := by
  repeat rw[Set.union_inter_distrib_right]
  rw[hA,hB,hC]
  simp only [union_self]



/--Another Auxilliary Lemma on how 2 sets are disjoint-/
lemma distict_sets_2{A : Set ℚ+}{B : Set ℚ+}{C : Set ℚ+}{D : Set ℚ+}{E : Set ℚ+}{F : Set ℚ+}(hAD : A ∩ D = ∅)(hBD : B ∩ D = ∅)(hCD : C ∩ D = ∅)(hAE : A ∩ E = ∅)(hBE : B ∩ E = ∅)(hCE : C ∩ E = ∅)(hAF : A ∩ F = ∅)(hBF : B ∩ F = ∅)(hCF : C ∩ F = ∅):  (A ∪ B ∪ C) ∩ (D ∪ E ∪ F) = ∅ := by
  repeat rw[Set.inter_distrib_left]
  rw[distinct_sets hAD hBD hCD]
  rw[distinct_sets hAE hBE hCE]
  rw[distinct_sets hAF hBF hCF]
  simp only [union_self]

/--If 2 balls are disjoint, smaller balls inside them are also disjoint.-/
lemma smaller_balls_disjoint_if_disjoint(ε₁ : ℝ)(ε₂ : ℝ)(ε₃ : ℝ)(ε₄ : ℝ)(h13 :ε₃ ≤ ε₁)(h24 : ε₄ ≤ ε₂)(hdisjoint : B ε₁ z₁ ∩ B ε₂ z₂ = ∅):  B ε₃ z₁ ∩ B ε₄ z₂ = ∅ := by
  rw[B,B]
  simp only [Real.norm_eq_abs]
  by_contra h
  push_neg at h
  rw[nonempty_def] at h
  match h with
  |⟨x, hx⟩ =>
  rw[Set.mem_inter_iff] at hx
  have hx1 : x ∈ B ε₁ z₁ := by
    rw[B]
    simp only [Real.norm_eq_abs, mem_setOf_eq]
    simp only [mem_setOf_eq] at hx
    constructor
    apply lt_of_lt_of_le (hx.1).1 h13
    exact (hx.1).2
  have hx2 : x ∈ B ε₂ z₂ := by
    rw[B]
    simp only [Real.norm_eq_abs, mem_setOf_eq]
    simp only [mem_setOf_eq] at hx
    constructor
    apply lt_of_lt_of_le (hx.2).1 h24
    exact (hx.2).2
  rw[← Set.disjoint_iff_inter_eq_empty,Set.disjoint_left] at hdisjoint
  apply hdisjoint hx1 hx2

/--We can find distinct neighbourhoods between 2 points.-/
lemma disjoint_nhs_gen (z1 : ℚ+)(z2 : ℚ+)(hz1hz2 : z1 ≠ z2):  ∃ ε₁ ε₂ : ℝ , (nhs_dit θ ε₁ z1 ∩ nhs_dit θ ε₂ z2 = ∅) ∧ (ε₁ > 0) ∧ (ε₂ > 0) := by
  match B_disjoint_ball_construct (z1.x - z1.y/θ) (z2.x - z2.y/θ) (distinct_points_z1_z2 θ hθ z1 z2 hz1hz2) with
  |⟨a,b ,hab,ha,hb⟩ =>
  match B_disjoint_ball_construct (z1.x - z1.y/θ) (z2.x + z2.y/θ) (distinct_points_z1_z2_diff θ hθ z1 z2 hz1hz2) with
  |⟨c,d,hcd,hc,hd⟩ =>
  have hθneg : Irrational (-θ) := Irrational.neg hθ
  match B_disjoint_ball_construct (z1.x - z1.y/(-θ)) (z2.x + z2.y/(-θ)) (distinct_points_z1_z2_diff (-θ) hθneg z1 z2 hz1hz2) with
  |⟨e,f,hef,he,hf⟩ =>
  rw[div_neg,div_neg,sub_neg_eq_add,← sub_eq_add_neg] at hef
  match B_disjoint_ball_construct (z1.x - z1.y/(-θ)) (z2.x - z2.y/(-θ)) (distinct_points_z1_z2 (-θ) hθneg z1 z2 hz1hz2) with
  |⟨g,h,hgh,hg,hh⟩ =>

  sorry


/--Irrational Slope Topology is a T2 Space.-/
instance IST_T₂ : T2Space ℚ+ := by
  rw[t2Space_iff_disjoint_nhds]
  intro z1 z2 hz1z2
  rw[Filter.disjoint_iff]
  have : ∃ ε₁ ε₂ : ℝ , (nhs_dit θ ε₁ z1 ∩ nhs_dit θ ε₂ z2 = ∅) ∧ (ε₁ > 0) ∧ (ε₂ > 0) := by sorry
  
  sorry
/-# Plan to forrmalize that this space is not T25
 * From [N. Bourbaki, *General Topology*][bourbaki1966], we know that all pen sets are also neighbourhood of a point, so if we prove that the    closure of any 2 neighbourhoods is disjoint, we are done.
 * Now, by the definition of closure in [N. Bourbaki, *General Topology*][bourbaki1966], we know that closure of a set is the set of all points such that every neighbourhood of x meets A.
 * But for any 2 fundamental neighbourhoods(ζ₁ , ζ₂), the open balls contained in those neighbourhoods(B₁ ∈ ζ₁,B₂ ∈ ζ₂ ) , the closure of the balls will be strips of rational numbers of slope `± θ` emanating from both sides of the balls.This is because, for a ball B₁ every neighbourhood(say ζ₃) of every point on those strips will intersect B₁ .
 * The proof of the above statement lies on the fact that the open ball(B₃ ∈  ζ₃) of the neighbourhoods will always intersect B₁ as the centre of the ball will be contained inside B₁. This because the centre of the balls of a neighbourhood of the point lie at the line of slope `± θ`.
 * So, the strips of rational numbers will always intersect, and hence the space cannot be T25. 
-/
end IrrationalSlopeTopology
